# -*- coding: utf-8 -*-
"""
Модуль для геометрических расчетов, проецирования и пр. (кроме функций, которые
непосредственно обрабатывают большие объемы данных)

Здесь часто используется термин коэффициенты проецировниая (a,b,с), которые
определены так:
  X'/ X = a * Y' + b
  Y'/ Y = c * X'/ X
где X', Y' - координаты на экране в пикселях относительно центра изображения,
             здесь Y' -- вверх
    X,  Y  - реальные координаты в метрах, на плоскости, относительно точки 
             пересечения плоскости с оптической осью (с прямой из центра
             изображения).
    размерности: [a] = 1/м, [b] = пкс/м, [c] - безразмерный, обычно a < 0.
    Не следует путать эти  X',Y' с обычными экранными координатами.

Здесь и далее слова "обычные экранные координаты" означают "как в bmp"
-- коорд. в пикселях от левого-верхнего угла, без преобразания изображения.
"""

from collections import namedtuple

ProjectingCoef = namedtuple('ProjectingCoef', ['a', 'b', 'c'])
IDENTICATL_PROJECTING = ProjectingCoef(0, 1, 1)

def trapezoid_inside_rectangle(rect, proj_coef, img_size):
    """
    Находит трапецию в экранных координатах, удовлетворяющую условиям:
      -может являться результатом проецирования некоторой прямоугольной области
       на экран при заданных параметрах проецирования
      -вписана в заданный экранный прямоугольник (кроме особо кривых случаев)
    Аргументы:
        rect (tuple 4*int ~ (x1, y1, x2, y2) ): лево-верх и право-низ пр-ка,
                                                обычные экранные координаты
        proj_coef(ProjectingCoef): см. docstring модуля.
        img_size (tuple (int,int)): ширина / высота изображения
    Возвращает:
        tuple 8*int -- экранные углов трапеции, начиная с левого-верхнего угла
                       и по часовой стрелке.
    """
    x1_px, y1_px, x2_px, y2_px = rect
    a, b, c = proj_coef
    w, h = img_size
    default_res = (x1_px, y1_px, x2_px, y1_px, x2_px, y2_px, x1_px, y2_px)
    if (abs(a) < 1e-6) and (abs(c) < 1e-6):
        return default_res
    x1_px -= w/2
    x2_px -= w/2
    y1_px = h/2 - y1_px
    y2_px = h/2 - y2_px
    # -- ограничивающий пр-к на экране
    
    denom1 = 1.0 * a * y1_px + b
    denom2 = 1.0 * a * y2_px + b
    if (abs(denom1) < 1e-6) or (abs(denom2) < 1e-6):
        return default_res
    # определяем x1, x2 -- ограничения слева/справа в реальных коорд.
    # по верху (j=1) и по низу (j=2)
    x1_ar = [0, 0]
    x2_ar = [0, 0]
    for j in [1, 2]:
        denom = [denom1, denom2] [j-1]
        x1 = x1_px / denom
        x1_ar[j - 1] = x1
        x2 = x2_px / denom
        x2_ar[j - 1] = x2
    x1 = max(x1_ar)
    x2 = min(x2_ar)

    # формируем реузльтат
    conv_x = lambda xnm_px: int(round(xnm_px)) + w/2    
    xlt_px = conv_x(x1 * (a * y1_px + b))
    xrt_px = conv_x(x2 * (a * y1_px + b))
    xrb_px = conv_x(x2 * (a * y2_px + b))
    xlb_px = conv_x(x1 * (a * y2_px + b))
    ynt_px = h/2 - y1_px
    ynb_px = h/2 - y2_px
    return (xlt_px, ynt_px, xrt_px, ynt_px, xrb_px, ynb_px, xlb_px, ynb_px)
    
    # Для теста:
    # A=-0.259815
    # B=101.8474
    # C=0.1589
    # размеры экрана: FullHD
    # сдвиг ко всем коорд: 310, 58
    # дальше идут разные трапеции, нарисованные старой прогой:
    # 758,441,  1155,441,  1076,595,  494,595
    # 1041,615  1445,615,  1566,894,  886,894
    
    
